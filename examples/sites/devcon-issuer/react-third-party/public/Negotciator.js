(() => { "use strict"; var e = { 360: (e, t, r) => { t.sc = ce, t.eN = function e(t, r, n) { if (n instanceof class { constructor(e = {}) { this.value = (0, s.getParametersValue)(e, "value", []), this.optional = (0, s.getParametersValue)(e, "optional", !1) } }) { const s = !1; for (let s = 0; s < n.value.length; s++)if (!0 === e(t, r, n.value[s]).verified) return { verified: !0, result: t }; if (!1 === s) { const e = { verified: !1, result: { error: "Wrong values for Choice type" } }; return n.hasOwnProperty("name") && (e.name = n.name), e } } if (n instanceof oe) return n.hasOwnProperty("name") && (t[n.name] = r), { verified: !0, result: t }; if (t instanceof Object == 0) return { verified: !1, result: { error: "Wrong root object" } }; if (r instanceof Object == 0) return { verified: !1, result: { error: "Wrong ASN.1 data" } }; if (n instanceof Object == 0) return { verified: !1, result: { error: "Wrong ASN.1 schema" } }; if ("idBlock" in n == 0) return { verified: !1, result: { error: "Wrong ASN.1 schema" } }; if ("fromBER" in n.idBlock == 0) return { verified: !1, result: { error: "Wrong ASN.1 schema" } }; if ("toBER" in n.idBlock == 0) return { verified: !1, result: { error: "Wrong ASN.1 schema" } }; const i = n.idBlock.toBER(!1); if (0 === i.byteLength) return { verified: !1, result: { error: "Error encoding idBlock for ASN.1 schema" } }; if (-1 === n.idBlock.fromBER(i, 0, i.byteLength)) return { verified: !1, result: { error: "Error decoding idBlock for ASN.1 schema" } }; if (!1 === n.idBlock.hasOwnProperty("tagClass")) return { verified: !1, result: { error: "Wrong ASN.1 schema" } }; if (n.idBlock.tagClass !== r.idBlock.tagClass) return { verified: !1, result: t }; if (!1 === n.idBlock.hasOwnProperty("tagNumber")) return { verified: !1, result: { error: "Wrong ASN.1 schema" } }; if (n.idBlock.tagNumber !== r.idBlock.tagNumber) return { verified: !1, result: t }; if (!1 === n.idBlock.hasOwnProperty("isConstructed")) return { verified: !1, result: { error: "Wrong ASN.1 schema" } }; if (n.idBlock.isConstructed !== r.idBlock.isConstructed) return { verified: !1, result: t }; if ("isHexOnly" in n.idBlock == 0) return { verified: !1, result: { error: "Wrong ASN.1 schema" } }; if (n.idBlock.isHexOnly !== r.idBlock.isHexOnly) return { verified: !1, result: t }; if (!0 === n.idBlock.isHexOnly) { if ("valueHex" in n.idBlock == 0) return { verified: !1, result: { error: "Wrong ASN.1 schema" } }; const e = new Uint8Array(n.idBlock.valueHex), s = new Uint8Array(r.idBlock.valueHex); if (e.length !== s.length) return { verified: !1, result: t }; for (let r = 0; r < e.length; r++)if (e[r] !== s[1]) return { verified: !1, result: t } } if (n.hasOwnProperty("name") && (n.name = n.name.replace(/^\s+|\s+$/g, ""), "" !== n.name && (t[n.name] = r)), !0 === n.idBlock.isConstructed) { let s = 0, i = { verified: !1 }, o = n.valueBlock.value.length; if (o > 0 && n.valueBlock.value[0] instanceof ae && (o = r.valueBlock.value.length), 0 === o) return { verified: !0, result: t }; if (0 === r.valueBlock.value.length && 0 !== n.valueBlock.value.length) { let e = !0; for (let t = 0; t < n.valueBlock.value.length; t++)e = e && (n.valueBlock.value[t].optional || !1); return !0 === e ? { verified: !0, result: t } : (n.hasOwnProperty("name") && (n.name = n.name.replace(/^\s+|\s+$/g, ""), "" !== n.name && delete t[n.name]), t.error = "Inconsistent object length", { verified: !1, result: t }) } for (let a = 0; a < o; a++)if (a - s >= r.valueBlock.value.length) { if (!1 === n.valueBlock.value[a].optional) { const e = { verified: !1, result: t }; return t.error = "Inconsistent length between ASN.1 data and schema", n.hasOwnProperty("name") && (n.name = n.name.replace(/^\s+|\s+$/g, ""), "" !== n.name && (delete t[n.name], e.name = n.name)), e } } else if (n.valueBlock.value[0] instanceof ae) { if (i = e(t, r.valueBlock.value[a], n.valueBlock.value[0].value), !1 === i.verified) { if (!0 !== n.valueBlock.value[0].optional) return n.hasOwnProperty("name") && (n.name = n.name.replace(/^\s+|\s+$/g, ""), "" !== n.name && delete t[n.name]), i; s++ } if ("name" in n.valueBlock.value[0] && n.valueBlock.value[0].name.length > 0) { let e = {}; e = "local" in n.valueBlock.value[0] && !0 === n.valueBlock.value[0].local ? r : t, void 0 === e[n.valueBlock.value[0].name] && (e[n.valueBlock.value[0].name] = []), e[n.valueBlock.value[0].name].push(r.valueBlock.value[a]) } } else if (i = e(t, r.valueBlock.value[a - s], n.valueBlock.value[a]), !1 === i.verified) { if (!0 !== n.valueBlock.value[a].optional) return n.hasOwnProperty("name") && (n.name = n.name.replace(/^\s+|\s+$/g, ""), "" !== n.name && delete t[n.name]), i; s++ } if (!1 === i.verified) { const e = { verified: !1, result: t }; return n.hasOwnProperty("name") && (n.name = n.name.replace(/^\s+|\s+$/g, ""), "" !== n.name && (delete t[n.name], e.name = n.name)), e } return { verified: !0, result: t } } if ("primitiveSchema" in n && "valueHex" in r.valueBlock) { const s = ce(r.valueBlock.valueHex); if (-1 === s.offset) { const e = { verified: !1, result: s.result }; return n.hasOwnProperty("name") && (n.name = n.name.replace(/^\s+|\s+$/g, ""), "" !== n.name && (delete t[n.name], e.name = n.name)), e } return e(t, s.result, n.primitiveSchema) } return { verified: !0, result: t } }, t.IK = t.rP = t.z8 = t._K = t.fi = t.T9 = void 0; var s = r(447); const n = [new Uint8Array([1])], i = "0123456789"; class o { constructor(e = {}) { this.blockLength = (0, s.getParametersValue)(e, "blockLength", 0), this.error = (0, s.getParametersValue)(e, "error", ""), this.warnings = (0, s.getParametersValue)(e, "warnings", []), this.valueBeforeDecode = "valueBeforeDecode" in e ? e.valueBeforeDecode.slice(0) : new ArrayBuffer(0) } static blockName() { return "baseBlock" } toJSON() { return { blockName: this.constructor.blockName(), blockLength: this.blockLength, error: this.error, warnings: this.warnings, valueBeforeDecode: (0, s.bufferToHexCodes)(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength) } } } const a = e => class extends e { constructor(e = {}) { super(e), this.isHexOnly = (0, s.getParametersValue)(e, "isHexOnly", !1), this.valueHex = "valueHex" in e ? e.valueHex.slice(0) : new ArrayBuffer(0) } static blockName() { return "hexBlock" } fromBER(e, t, r) { return !1 === (0, s.checkBufferParams)(this, e, t, r) ? -1 : 0 === new Uint8Array(e, t, r).length ? (this.warnings.push("Zero buffer length"), t) : (this.valueHex = e.slice(t, t + r), this.blockLength = r, t + r) } toBER(e = !1) { return !0 !== this.isHexOnly ? (this.error = 'Flag "isHexOnly" is not set, abort', new ArrayBuffer(0)) : !0 === e ? new ArrayBuffer(this.valueHex.byteLength) : this.valueHex.slice(0) } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.blockName = this.constructor.blockName(), e.isHexOnly = this.isHexOnly, e.valueHex = (0, s.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength), e } }; class l extends (a(o)) { constructor(e = {}) { super(), "idBlock" in e ? (this.isHexOnly = (0, s.getParametersValue)(e.idBlock, "isHexOnly", !1), this.valueHex = (0, s.getParametersValue)(e.idBlock, "valueHex", new ArrayBuffer(0)), this.tagClass = (0, s.getParametersValue)(e.idBlock, "tagClass", -1), this.tagNumber = (0, s.getParametersValue)(e.idBlock, "tagNumber", -1), this.isConstructed = (0, s.getParametersValue)(e.idBlock, "isConstructed", !1)) : (this.tagClass = -1, this.tagNumber = -1, this.isConstructed = !1) } static blockName() { return "identificationBlock" } toBER(e = !1) { let t, r, n = 0; switch (this.tagClass) { case 1: n |= 0; break; case 2: n |= 64; break; case 3: n |= 128; break; case 4: n |= 192; break; default: return this.error = "Unknown tag class", new ArrayBuffer(0) }if (this.isConstructed && (n |= 32), this.tagNumber < 31 && !this.isHexOnly) { if (t = new ArrayBuffer(1), r = new Uint8Array(t), !e) { let e = this.tagNumber; e &= 31, n |= e, r[0] = n } return t } if (!1 === this.isHexOnly) { const i = (0, s.utilToBase)(this.tagNumber, 7), o = new Uint8Array(i), a = i.byteLength; if (t = new ArrayBuffer(a + 1), r = new Uint8Array(t), r[0] = 31 | n, !e) { for (let e = 0; e < a - 1; e++)r[e + 1] = 128 | o[e]; r[a] = o[a - 1] } return t } if (t = new ArrayBuffer(this.valueHex.byteLength + 1), r = new Uint8Array(t), r[0] = 31 | n, !1 === e) { const e = new Uint8Array(this.valueHex); for (let t = 0; t < e.length - 1; t++)r[t + 1] = 128 | e[t]; r[this.valueHex.byteLength] = e[e.length - 1] } return t } fromBER(e, t, r) { if (!1 === (0, s.checkBufferParams)(this, e, t, r)) return -1; const n = new Uint8Array(e, t, r); if (0 === n.length) return this.error = "Zero buffer length", -1; switch (192 & n[0]) { case 0: this.tagClass = 1; break; case 64: this.tagClass = 2; break; case 128: this.tagClass = 3; break; case 192: this.tagClass = 4; break; default: return this.error = "Unknown tag class", -1 }this.isConstructed = 32 == (32 & n[0]), this.isHexOnly = !1; const i = 31 & n[0]; if (31 !== i) this.tagNumber = i, this.blockLength = 1; else { let e = 1; this.valueHex = new ArrayBuffer(255); let t = 255, r = new Uint8Array(this.valueHex); for (; 128 & n[e];) { if (r[e - 1] = 127 & n[e], e++, e >= n.length) return this.error = "End of input reached before message was fully decoded", -1; if (e === t) { t += 255; const e = new ArrayBuffer(t), s = new Uint8Array(e); for (let e = 0; e < r.length; e++)s[e] = r[e]; this.valueHex = new ArrayBuffer(t), r = new Uint8Array(this.valueHex) } } this.blockLength = e + 1, r[e - 1] = 127 & n[e]; const i = new ArrayBuffer(e), o = new Uint8Array(i); for (let t = 0; t < e; t++)o[t] = r[t]; this.valueHex = new ArrayBuffer(e), r = new Uint8Array(this.valueHex), r.set(o), this.blockLength <= 9 ? this.tagNumber = (0, s.utilFromBase)(r, 7) : (this.isHexOnly = !0, this.warnings.push("Tag too long, represented as hex-coded")) } if (1 === this.tagClass && this.isConstructed) switch (this.tagNumber) { case 1: case 2: case 5: case 6: case 9: case 13: case 14: case 23: case 24: case 31: case 32: case 33: case 34: return this.error = "Constructed encoding used for primitive type", -1 }return t + this.blockLength } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.blockName = this.constructor.blockName(), e.tagClass = this.tagClass, e.tagNumber = this.tagNumber, e.isConstructed = this.isConstructed, e } } class c extends o { constructor(e = {}) { super(), "lenBlock" in e ? (this.isIndefiniteForm = (0, s.getParametersValue)(e.lenBlock, "isIndefiniteForm", !1), this.longFormUsed = (0, s.getParametersValue)(e.lenBlock, "longFormUsed", !1), this.length = (0, s.getParametersValue)(e.lenBlock, "length", 0)) : (this.isIndefiniteForm = !1, this.longFormUsed = !1, this.length = 0) } static blockName() { return "lengthBlock" } fromBER(e, t, r) { if (!1 === (0, s.checkBufferParams)(this, e, t, r)) return -1; const n = new Uint8Array(e, t, r); if (0 === n.length) return this.error = "Zero buffer length", -1; if (255 === n[0]) return this.error = "Length block 0xFF is reserved by standard", -1; if (this.isIndefiniteForm = 128 === n[0], !0 === this.isIndefiniteForm) return this.blockLength = 1, t + this.blockLength; if (this.longFormUsed = !!(128 & n[0]), !1 === this.longFormUsed) return this.length = n[0], this.blockLength = 1, t + this.blockLength; const i = 127 & n[0]; if (i > 8) return this.error = "Too big integer", -1; if (i + 1 > n.length) return this.error = "End of input reached before message was fully decoded", -1; const o = new Uint8Array(i); for (let e = 0; e < i; e++)o[e] = n[e + 1]; return 0 === o[i - 1] && this.warnings.push("Needlessly long encoded length"), this.length = (0, s.utilFromBase)(o, 8), this.longFormUsed && this.length <= 127 && this.warnings.push("Unneccesary usage of long length form"), this.blockLength = i + 1, t + this.blockLength } toBER(e = !1) { let t, r; if (this.length > 127 && (this.longFormUsed = !0), this.isIndefiniteForm) return t = new ArrayBuffer(1), !1 === e && (r = new Uint8Array(t), r[0] = 128), t; if (!0 === this.longFormUsed) { const n = (0, s.utilToBase)(this.length, 8); if (n.byteLength > 127) return this.error = "Too big length", new ArrayBuffer(0); if (t = new ArrayBuffer(n.byteLength + 1), !0 === e) return t; const i = new Uint8Array(n); r = new Uint8Array(t), r[0] = 128 | n.byteLength; for (let e = 0; e < n.byteLength; e++)r[e + 1] = i[e]; return t } return t = new ArrayBuffer(1), !1 === e && (r = new Uint8Array(t), r[0] = this.length), t } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.blockName = this.constructor.blockName(), e.isIndefiniteForm = this.isIndefiniteForm, e.longFormUsed = this.longFormUsed, e.length = this.length, e } } class h extends o { constructor(e = {}) { super(e) } static blockName() { return "valueBlock" } fromBER(e, t, r) { throw TypeError('User need to make a specific function in a class which extends "ValueBlock"') } toBER(e = !1) { throw TypeError('User need to make a specific function in a class which extends "ValueBlock"') } } class u extends o { constructor(e = {}, t = h) { super(e), "name" in e && (this.name = e.name), "optional" in e && (this.optional = e.optional), "primitiveSchema" in e && (this.primitiveSchema = e.primitiveSchema), this.idBlock = new l(e), this.lenBlock = new c(e), this.valueBlock = new t(e) } static blockName() { return "BaseBlock" } fromBER(e, t, r) { const s = this.valueBlock.fromBER(e, t, !0 === this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length); return -1 === s ? (this.error = this.valueBlock.error, s) : (0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), 0 === this.valueBlock.error.length && (this.blockLength += this.valueBlock.blockLength), s) } toBER(e = !1) { let t; const r = this.idBlock.toBER(e), n = this.valueBlock.toBER(!0); this.lenBlock.length = n.byteLength; const i = this.lenBlock.toBER(e); let o; if (t = (0, s.utilConcatBuf)(r, i), o = !1 === e ? this.valueBlock.toBER(e) : new ArrayBuffer(this.lenBlock.length), t = (0, s.utilConcatBuf)(t, o), !0 === this.lenBlock.isIndefiniteForm) { const r = new ArrayBuffer(2); if (!1 === e) { const e = new Uint8Array(r); e[0] = 0, e[1] = 0 } t = (0, s.utilConcatBuf)(t, r) } return t } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.idBlock = this.idBlock.toJSON(), e.lenBlock = this.lenBlock.toJSON(), e.valueBlock = this.valueBlock.toJSON(), "name" in this && (e.name = this.name), "optional" in this && (e.optional = this.optional), "primitiveSchema" in this && (e.primitiveSchema = this.primitiveSchema.toJSON()), e } } class f extends h { constructor(e = {}) { super(e), this.valueHex = "valueHex" in e ? e.valueHex.slice(0) : new ArrayBuffer(0), this.isHexOnly = (0, s.getParametersValue)(e, "isHexOnly", !0) } fromBER(e, t, r) { if (!1 === (0, s.checkBufferParams)(this, e, t, r)) return -1; const n = new Uint8Array(e, t, r); if (0 === n.length) return this.warnings.push("Zero buffer length"), t; this.valueHex = new ArrayBuffer(n.length); const i = new Uint8Array(this.valueHex); for (let e = 0; e < n.length; e++)i[e] = n[e]; return this.blockLength = r, t + r } toBER(e = !1) { return this.valueHex.slice(0) } static blockName() { return "PrimitiveValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.valueHex = (0, s.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength), e.isHexOnly = this.isHexOnly, e } } class g extends u { constructor(e = {}) { super(e, f), this.idBlock.isConstructed = !1 } static blockName() { return "PRIMITIVE" } } class d extends h { constructor(e = {}) { super(e), this.value = (0, s.getParametersValue)(e, "value", []), this.isIndefiniteForm = (0, s.getParametersValue)(e, "isIndefiniteForm", !1) } fromBER(e, t, r) { const n = t, i = r; if (!1 === (0, s.checkBufferParams)(this, e, t, r)) return -1; if (0 === new Uint8Array(e, t, r).length) return this.warnings.push("Zero buffer length"), t; let o = t; for (; (!0 === this.isIndefiniteForm ? 1 : r) > 0;) { const t = le(e, o, r); if (-1 === t.offset) return this.error = t.result.error, this.warnings.concat(t.result.warnings), -1; if (o = t.offset, this.blockLength += t.result.blockLength, r -= t.result.blockLength, this.value.push(t.result), !0 === this.isIndefiniteForm && t.result.constructor.blockName() === B.blockName()) break } return !0 === this.isIndefiniteForm && (this.value[this.value.length - 1].constructor.blockName() === B.blockName() ? this.value.pop() : this.warnings.push("No EndOfContent block encoded")), this.valueBeforeDecode = e.slice(n, n + i), o } toBER(e = !1) { let t = new ArrayBuffer(0); for (let r = 0; r < this.value.length; r++) { const n = this.value[r].toBER(e); t = (0, s.utilConcatBuf)(t, n) } return t } static blockName() { return "ConstructedValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } e.isIndefiniteForm = this.isIndefiniteForm, e.value = []; for (let t = 0; t < this.value.length; t++)e.value.push(this.value[t].toJSON()); return e } } class m extends u { constructor(e = {}) { super(e, d), this.idBlock.isConstructed = !0 } static blockName() { return "CONSTRUCTED" } fromBER(e, t, r) { this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm; const s = this.valueBlock.fromBER(e, t, !0 === this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length); return -1 === s ? (this.error = this.valueBlock.error, s) : (0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), 0 === this.valueBlock.error.length && (this.blockLength += this.valueBlock.blockLength), s) } } class k extends h { constructor(e = {}) { super(e) } fromBER(e, t, r) { return t } toBER(e = !1) { return new ArrayBuffer(0) } static blockName() { return "EndOfContentValueBlock" } } class B extends u { constructor(e = {}) { super(e, k), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 0 } static blockName() { return "EndOfContent" } } class v extends h { constructor(e = {}) { super(e), this.value = (0, s.getParametersValue)(e, "value", !1), this.isHexOnly = (0, s.getParametersValue)(e, "isHexOnly", !1), "valueHex" in e ? this.valueHex = e.valueHex.slice(0) : (this.valueHex = new ArrayBuffer(1), !0 === this.value && (new Uint8Array(this.valueHex)[0] = 255)) } fromBER(e, t, r) { if (!1 === (0, s.checkBufferParams)(this, e, t, r)) return -1; const n = new Uint8Array(e, t, r); r > 1 && this.warnings.push("Boolean value encoded in more then 1 octet"), this.isHexOnly = !0, this.valueHex = new ArrayBuffer(n.length); const i = new Uint8Array(this.valueHex); for (let e = 0; e < n.length; e++)i[e] = n[e]; return 0 !== s.utilDecodeTC.call(this) ? this.value = !0 : this.value = !1, this.blockLength = r, t + r } toBER(e = !1) { return this.valueHex } static blockName() { return "BooleanValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.value = this.value, e.isHexOnly = this.isHexOnly, e.valueHex = (0, s.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength), e } } class b extends u { constructor(e = {}) { super(e, v), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 1 } static blockName() { return "Boolean" } } class y extends m { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 16 } static blockName() { return "Sequence" } } t.T9 = y; class w extends m { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 17 } static blockName() { return "Set" } } class p extends u { constructor(e = {}) { super(e, o), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 5 } static blockName() { return "Null" } fromBER(e, t, r) { return this.lenBlock.length > 0 && this.warnings.push("Non-zero length of value block for Null type"), 0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), this.blockLength += r, t + r > e.byteLength ? (this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)", -1) : t + r } toBER(e = !1) { const t = new ArrayBuffer(2); if (!0 === e) return t; const r = new Uint8Array(t); return r[0] = 5, r[1] = 0, t } } class x extends (a(d)) { constructor(e = {}) { super(e), this.isConstructed = (0, s.getParametersValue)(e, "isConstructed", !1) } fromBER(e, t, r) { let s = 0; if (!0 === this.isConstructed) { if (this.isHexOnly = !1, s = d.prototype.fromBER.call(this, e, t, r), -1 === s) return s; for (let e = 0; e < this.value.length; e++) { const t = this.value[e].constructor.blockName(); if (t === B.blockName()) { if (!0 === this.isIndefiniteForm) break; return this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only", -1 } if (t !== N.blockName()) return this.error = "OCTET STRING may consists of OCTET STRINGs only", -1 } } else this.isHexOnly = !0, s = super.fromBER(e, t, r), this.blockLength = r; return s } toBER(e = !1) { if (!0 === this.isConstructed) return d.prototype.toBER.call(this, e); let t = new ArrayBuffer(this.valueHex.byteLength); return !0 === e || 0 === this.valueHex.byteLength || (t = this.valueHex.slice(0)), t } static blockName() { return "OctetStringValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.isConstructed = this.isConstructed, e.isHexOnly = this.isHexOnly, e.valueHex = (0, s.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength), e } } class N extends u { constructor(e = {}) { super(e, x), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 4 } fromBER(e, t, r) { return this.valueBlock.isConstructed = this.idBlock.isConstructed, this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm, 0 === r ? (0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), t) : super.fromBER(e, t, r) } static blockName() { return "OctetString" } isEqual(e) { return e instanceof N != 0 && JSON.stringify(this) === JSON.stringify(e) } } t.fi = N; class A extends (a(d)) { constructor(e = {}) { super(e), this.unusedBits = (0, s.getParametersValue)(e, "unusedBits", 0), this.isConstructed = (0, s.getParametersValue)(e, "isConstructed", !1), this.blockLength = this.valueHex.byteLength } fromBER(e, t, r) { if (0 === r) return t; let n = -1; if (!0 === this.isConstructed) { if (n = d.prototype.fromBER.call(this, e, t, r), -1 === n) return n; for (let e = 0; e < this.value.length; e++) { const t = this.value[e].constructor.blockName(); if (t === B.blockName()) { if (!0 === this.isIndefiniteForm) break; return this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only", -1 } if (t !== S.blockName()) return this.error = "BIT STRING may consists of BIT STRINGs only", -1; if (this.unusedBits > 0 && this.value[e].valueBlock.unusedBits > 0) return this.error = 'Usign of "unused bits" inside constructive BIT STRING allowed for least one only', -1; if (this.unusedBits = this.value[e].valueBlock.unusedBits, this.unusedBits > 7) return this.error = "Unused bits for BitString must be in range 0-7", -1 } return n } if (!1 === (0, s.checkBufferParams)(this, e, t, r)) return -1; const i = new Uint8Array(e, t, r); if (this.unusedBits = i[0], this.unusedBits > 7) return this.error = "Unused bits for BitString must be in range 0-7", -1; this.valueHex = new ArrayBuffer(i.length - 1); const o = new Uint8Array(this.valueHex); for (let e = 0; e < r - 1; e++)o[e] = i[e + 1]; return this.blockLength = i.length, t + r } toBER(e = !1) { if (!0 === this.isConstructed) return d.prototype.toBER.call(this, e); if (!0 === e) return new ArrayBuffer(this.valueHex.byteLength + 1); if (0 === this.valueHex.byteLength) return new ArrayBuffer(0); const t = new Uint8Array(this.valueHex), r = new ArrayBuffer(this.valueHex.byteLength + 1), s = new Uint8Array(r); s[0] = this.unusedBits; for (let e = 0; e < this.valueHex.byteLength; e++)s[e + 1] = t[e]; return r } static blockName() { return "BitStringValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.unusedBits = this.unusedBits, e.isConstructed = this.isConstructed, e.isHexOnly = this.isHexOnly, e.valueHex = (0, s.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength), e } } class S extends u { constructor(e = {}) { super(e, A), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 3 } static blockName() { return "BitString" } fromBER(e, t, r) { return 0 === r ? t : (this.valueBlock.isConstructed = this.idBlock.isConstructed, this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm, super.fromBER(e, t, r)) } isEqual(e) { return e instanceof S != 0 && JSON.stringify(this) === JSON.stringify(e) } } t._K = S; class C extends (a(h)) { constructor(e = {}) { super(e), "value" in e && (this.valueDec = e.value) } set valueHex(e) { this._valueHex = e.slice(0), e.byteLength >= 4 ? (this.warnings.push("Too big Integer for decoding, hex only"), this.isHexOnly = !0, this._valueDec = 0) : (this.isHexOnly = !1, e.byteLength > 0 && (this._valueDec = s.utilDecodeTC.call(this))) } get valueHex() { return this._valueHex } set valueDec(e) { this._valueDec = e, this.isHexOnly = !1, this._valueHex = (0, s.utilEncodeTC)(e) } get valueDec() { return this._valueDec } fromDER(e, t, r, s = 0) { const n = this.fromBER(e, t, r); if (-1 === n) return n; const i = new Uint8Array(this._valueHex); if (0 === i[0] && 0 != (128 & i[1])) { const e = new ArrayBuffer(this._valueHex.byteLength - 1); new Uint8Array(e).set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1)), this._valueHex = e.slice(0) } else if (0 !== s && this._valueHex.byteLength < s) { s - this._valueHex.byteLength > 1 && (s = this._valueHex.byteLength + 1); const e = new ArrayBuffer(s); new Uint8Array(e).set(i, s - this._valueHex.byteLength), this._valueHex = e.slice(0) } return n } toDER(e = !1) { const t = new Uint8Array(this._valueHex); switch (!0) { case 0 != (128 & t[0]): { const e = new ArrayBuffer(this._valueHex.byteLength + 1), r = new Uint8Array(e); r[0] = 0, r.set(t, 1), this._valueHex = e.slice(0) } break; case 0 === t[0] && 0 == (128 & t[1]): { const e = new ArrayBuffer(this._valueHex.byteLength - 1); new Uint8Array(e).set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1)), this._valueHex = e.slice(0) } }return this.toBER(e) } fromBER(e, t, r) { const s = super.fromBER(e, t, r); return -1 === s ? s : (this.blockLength = r, t + r) } toBER(e = !1) { return this.valueHex.slice(0) } static blockName() { return "IntegerValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.valueDec = this.valueDec, e } toString() { function e(e, t) { const r = new Uint8Array([0]); let n = new Uint8Array(e), i = new Uint8Array(t), o = n.slice(0); const a = o.length - 1; let l = i.slice(0); const c = l.length - 1; let h = 0, u = 0; for (let e = c < a ? a : c; e >= 0; e--, u++) { switch (!0) { case u < l.length: h = o[a - u] + l[c - u] + r[0]; break; default: h = o[a - u] + r[0] }switch (r[0] = h / 10, !0) { case u >= o.length: o = (0, s.utilConcatView)(new Uint8Array([h % 10]), o); break; default: o[a - u] = h % 10 } } return r[0] > 0 && (o = (0, s.utilConcatView)(r, o)), o.slice(0) } function t(e) { if (e >= n.length) for (let t = n.length; t <= e; t++) { const e = new Uint8Array([0]); let r = n[t - 1].slice(0); for (let t = r.length - 1; t >= 0; t--) { const s = new Uint8Array([(r[t] << 1) + e[0]]); e[0] = s[0] / 10, r[t] = s[0] % 10 } e[0] > 0 && (r = (0, s.utilConcatView)(e, r)), n.push(r) } return n[e] } function r(e, t) { let r = 0, s = new Uint8Array(e), n = new Uint8Array(t), i = s.slice(0); const o = i.length - 1; let a = n.slice(0); const l = a.length - 1; let c, h = 0; for (let e = l; e >= 0; e--, h++)switch (c = i[o - h] - a[l - h] - r, !0) { case c < 0: r = 1, i[o - h] = c + 10; break; default: r = 0, i[o - h] = c }if (r > 0) for (let e = o - l + 1; e >= 0; e--, h++) { if (c = i[o - h] - r, !(c < 0)) { r = 0, i[o - h] = c; break } r = 1, i[o - h] = c + 10 } return i.slice() } const o = 8 * this._valueHex.byteLength - 1; let a, l = new Uint8Array(8 * this._valueHex.byteLength / 3), c = 0; const h = new Uint8Array(this._valueHex); let u = "", f = !1; for (let s = this._valueHex.byteLength - 1; s >= 0; s--) { a = h[s]; for (let s = 0; s < 8; s++) { if (1 == (1 & a)) switch (c) { case o: l = r(t(c), l), u = "-"; break; default: l = e(l, t(c)) }c++, a >>= 1 } } for (let e = 0; e < l.length; e++)l[e] && (f = !0), f && (u += i.charAt(l[e])); return !1 === f && (u += i.charAt(0)), u } } class L extends u { constructor(e = {}) { super(e, C), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 2 } static blockName() { return "Integer" } isEqual(e) { return e instanceof L ? this.valueBlock.isHexOnly && e.valueBlock.isHexOnly ? (0, s.isEqualBuffer)(this.valueBlock.valueHex, e.valueBlock.valueHex) : this.valueBlock.isHexOnly === e.valueBlock.isHexOnly && this.valueBlock.valueDec === e.valueBlock.valueDec : e instanceof ArrayBuffer && (0, s.isEqualBuffer)(this.valueBlock.valueHex, e) } convertToDER() { const e = new L({ valueHex: this.valueBlock.valueHex }); return e.valueBlock.toDER(), e } convertFromDER() { const e = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength, t = new L({ valueHex: this.valueBlock.valueHex }); return t.valueBlock.fromDER(t.valueBlock.valueHex, 0, t.valueBlock.valueHex.byteLength, e), t } } t.z8 = L; class H extends L { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 10 } static blockName() { return "Enumerated" } } class O extends (a(o)) { constructor(e = {}) { super(e), this.valueDec = (0, s.getParametersValue)(e, "valueDec", -1), this.isFirstSid = (0, s.getParametersValue)(e, "isFirstSid", !1) } static blockName() { return "sidBlock" } fromBER(e, t, r) { if (0 === r) return t; if (!1 === (0, s.checkBufferParams)(this, e, t, r)) return -1; const n = new Uint8Array(e, t, r); this.valueHex = new ArrayBuffer(r); let i = new Uint8Array(this.valueHex); for (let e = 0; e < r && (i[e] = 127 & n[e], this.blockLength++, 0 != (128 & n[e])); e++); const o = new ArrayBuffer(this.blockLength), a = new Uint8Array(o); for (let e = 0; e < this.blockLength; e++)a[e] = i[e]; return this.valueHex = o.slice(0), i = new Uint8Array(this.valueHex), 0 != (128 & n[this.blockLength - 1]) ? (this.error = "End of input reached before message was fully decoded", -1) : (0 === i[0] && this.warnings.push("Needlessly long format of SID encoding"), this.blockLength <= 8 ? this.valueDec = (0, s.utilFromBase)(i, 7) : (this.isHexOnly = !0, this.warnings.push("Too big SID for decoding, hex only")), t + this.blockLength) } toBER(e = !1) { let t, r; if (this.isHexOnly) { if (!0 === e) return new ArrayBuffer(this.valueHex.byteLength); const s = new Uint8Array(this.valueHex); t = new ArrayBuffer(this.blockLength), r = new Uint8Array(t); for (let e = 0; e < this.blockLength - 1; e++)r[e] = 128 | s[e]; return r[this.blockLength - 1] = s[this.blockLength - 1], t } const n = (0, s.utilToBase)(this.valueDec, 7); if (0 === n.byteLength) return this.error = "Error during encoding SID value", new ArrayBuffer(0); if (t = new ArrayBuffer(n.byteLength), !1 === e) { const e = new Uint8Array(n); r = new Uint8Array(t); for (let t = 0; t < n.byteLength - 1; t++)r[t] = 128 | e[t]; r[n.byteLength - 1] = e[n.byteLength - 1] } return t } toString() { let e = ""; if (!0 === this.isHexOnly) e = (0, s.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength); else if (this.isFirstSid) { let t = this.valueDec; this.valueDec <= 39 ? e = "0." : this.valueDec <= 79 ? (e = "1.", t -= 40) : (e = "2.", t -= 80), e += t.toString() } else e = this.valueDec.toString(); return e } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.valueDec = this.valueDec, e.isFirstSid = this.isFirstSid, e } } class U extends h { constructor(e = {}) { super(e), this.fromString((0, s.getParametersValue)(e, "value", "")) } fromBER(e, t, r) { let s = t; for (; r > 0;) { const t = new O; if (s = t.fromBER(e, s, r), -1 === s) return this.blockLength = 0, this.error = t.error, s; 0 === this.value.length && (t.isFirstSid = !0), this.blockLength += t.blockLength, r -= t.blockLength, this.value.push(t) } return s } toBER(e = !1) { let t = new ArrayBuffer(0); for (let r = 0; r < this.value.length; r++) { const n = this.value[r].toBER(e); if (0 === n.byteLength) return this.error = this.value[r].error, new ArrayBuffer(0); t = (0, s.utilConcatBuf)(t, n) } return t } fromString(e) { this.value = []; let t = 0, r = 0, s = "", n = !1; do { if (r = e.indexOf(".", t), s = -1 === r ? e.substr(t) : e.substr(t, r - t), t = r + 1, n) { const e = this.value[0]; let t = 0; switch (e.valueDec) { case 0: break; case 1: t = 40; break; case 2: t = 80; break; default: return this.value = [], !1 }const r = parseInt(s, 10); if (isNaN(r)) return !0; e.valueDec = r + t, n = !1 } else { const e = new O; if (e.valueDec = parseInt(s, 10), isNaN(e.valueDec)) return !0; 0 === this.value.length && (e.isFirstSid = !0, n = !0), this.value.push(e) } } while (-1 !== r); return !0 } toString() { let e = "", t = !1; for (let r = 0; r < this.value.length; r++) { t = this.value[r].isHexOnly; let s = this.value[r].toString(); 0 !== r && (e = `${e}.`), t ? (s = `{${s}}`, this.value[r].isFirstSid ? e = `2.{${s} - 80}` : e += s) : e += s } return e } static blockName() { return "ObjectIdentifierValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } e.value = this.toString(), e.sidArray = []; for (let t = 0; t < this.value.length; t++)e.sidArray.push(this.value[t].toJSON()); return e } } class I extends u { constructor(e = {}) { super(e, U), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 6 } static blockName() { return "ObjectIdentifier" } } t.rP = I; class E extends (a(o)) { constructor(e = {}) { super(e), this.isHexOnly = !0, this.value = "" } static blockName() { return "Utf8StringValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.value = this.value, e } } class T extends u { constructor(e = {}) { super(e, E), "value" in e && this.fromString(e.value), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 12 } static blockName() { return "Utf8String" } fromBER(e, t, r) { const s = this.valueBlock.fromBER(e, t, !0 === this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length); return -1 === s ? (this.error = this.valueBlock.error, s) : (this.fromBuffer(this.valueBlock.valueHex), 0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), 0 === this.valueBlock.error.length && (this.blockLength += this.valueBlock.blockLength), s) } fromBuffer(e) { this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(e)); try { this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value)) } catch (e) { this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`) } } fromString(e) { const t = unescape(encodeURIComponent(e)), r = t.length; this.valueBlock.valueHex = new ArrayBuffer(r); const s = new Uint8Array(this.valueBlock.valueHex); for (let e = 0; e < r; e++)s[e] = t.charCodeAt(e); this.valueBlock.value = e } } class R extends (a(o)) { constructor(e = {}) { super(e), this.valueDec = (0, s.getParametersValue)(e, "valueDec", -1) } static blockName() { return "relativeSidBlock" } fromBER(e, t, r) { if (0 === r) return t; if (!1 === (0, s.checkBufferParams)(this, e, t, r)) return -1; const n = new Uint8Array(e, t, r); this.valueHex = new ArrayBuffer(r); let i = new Uint8Array(this.valueHex); for (let e = 0; e < r && (i[e] = 127 & n[e], this.blockLength++, 0 != (128 & n[e])); e++); const o = new ArrayBuffer(this.blockLength), a = new Uint8Array(o); for (let e = 0; e < this.blockLength; e++)a[e] = i[e]; return this.valueHex = o.slice(0), i = new Uint8Array(this.valueHex), 0 != (128 & n[this.blockLength - 1]) ? (this.error = "End of input reached before message was fully decoded", -1) : (0 === i[0] && this.warnings.push("Needlessly long format of SID encoding"), this.blockLength <= 8 ? this.valueDec = (0, s.utilFromBase)(i, 7) : (this.isHexOnly = !0, this.warnings.push("Too big SID for decoding, hex only")), t + this.blockLength) } toBER(e = !1) { let t, r; if (this.isHexOnly) { if (!0 === e) return new ArrayBuffer(this.valueHex.byteLength); const s = new Uint8Array(this.valueHex); t = new ArrayBuffer(this.blockLength), r = new Uint8Array(t); for (let e = 0; e < this.blockLength - 1; e++)r[e] = 128 | s[e]; return r[this.blockLength - 1] = s[this.blockLength - 1], t } const n = (0, s.utilToBase)(this.valueDec, 7); if (0 === n.byteLength) return this.error = "Error during encoding SID value", new ArrayBuffer(0); if (t = new ArrayBuffer(n.byteLength), !1 === e) { const e = new Uint8Array(n); r = new Uint8Array(t); for (let t = 0; t < n.byteLength - 1; t++)r[t] = 128 | e[t]; r[n.byteLength - 1] = e[n.byteLength - 1] } return t } toString() { let e = ""; return e = !0 === this.isHexOnly ? (0, s.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength) : this.valueDec.toString(), e } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.valueDec = this.valueDec, e } } class P extends h { constructor(e = {}) { super(e), this.fromString((0, s.getParametersValue)(e, "value", "")) } fromBER(e, t, r) { let s = t; for (; r > 0;) { const t = new R; if (s = t.fromBER(e, s, r), -1 === s) return this.blockLength = 0, this.error = t.error, s; this.blockLength += t.blockLength, r -= t.blockLength, this.value.push(t) } return s } toBER(e = !1) { let t = new ArrayBuffer(0); for (let r = 0; r < this.value.length; r++) { const n = this.value[r].toBER(e); if (0 === n.byteLength) return this.error = this.value[r].error, new ArrayBuffer(0); t = (0, s.utilConcatBuf)(t, n) } return t } fromString(e) { this.value = []; let t = 0, r = 0, s = ""; do { r = e.indexOf(".", t), s = -1 === r ? e.substr(t) : e.substr(t, r - t), t = r + 1; const n = new R; if (n.valueDec = parseInt(s, 10), isNaN(n.valueDec)) return !0; this.value.push(n) } while (-1 !== r); return !0 } toString() { let e = "", t = !1; for (let r = 0; r < this.value.length; r++) { t = this.value[r].isHexOnly; let s = this.value[r].toString(); 0 !== r && (e = `${e}.`), t ? (s = `{${s}}`, e += s) : e += s } return e } static blockName() { return "RelativeObjectIdentifierValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } e.value = this.toString(), e.sidArray = []; for (let t = 0; t < this.value.length; t++)e.sidArray.push(this.value[t].toJSON()); return e } } class D extends u { constructor(e = {}) { super(e, P), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 13 } static blockName() { return "RelativeObjectIdentifier" } } class F extends (a(o)) { constructor(e = {}) { super(e), this.isHexOnly = !0, this.value = "" } static blockName() { return "BmpStringValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.value = this.value, e } } class V extends u { constructor(e = {}) { super(e, F), "value" in e && this.fromString(e.value), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 30 } static blockName() { return "BmpString" } fromBER(e, t, r) { const s = this.valueBlock.fromBER(e, t, !0 === this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length); return -1 === s ? (this.error = this.valueBlock.error, s) : (this.fromBuffer(this.valueBlock.valueHex), 0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), 0 === this.valueBlock.error.length && (this.blockLength += this.valueBlock.blockLength), s) } fromBuffer(e) { const t = e.slice(0), r = new Uint8Array(t); for (let e = 0; e < r.length; e += 2) { const t = r[e]; r[e] = r[e + 1], r[e + 1] = t } this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(t)) } fromString(e) { const t = e.length; this.valueBlock.valueHex = new ArrayBuffer(2 * t); const r = new Uint8Array(this.valueBlock.valueHex); for (let n = 0; n < t; n++) { const t = (0, s.utilToBase)(e.charCodeAt(n), 8), i = new Uint8Array(t); if (i.length > 2) continue; const o = 2 - i.length; for (let e = i.length - 1; e >= 0; e--)r[2 * n + e + o] = i[e] } this.valueBlock.value = e } } class J extends (a(o)) { constructor(e = {}) { super(e), this.isHexOnly = !0, this.value = "" } static blockName() { return "UniversalStringValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.value = this.value, e } } class M extends u { constructor(e = {}) { super(e, J), "value" in e && this.fromString(e.value), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 28 } static blockName() { return "UniversalString" } fromBER(e, t, r) { const s = this.valueBlock.fromBER(e, t, !0 === this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length); return -1 === s ? (this.error = this.valueBlock.error, s) : (this.fromBuffer(this.valueBlock.valueHex), 0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), 0 === this.valueBlock.error.length && (this.blockLength += this.valueBlock.blockLength), s) } fromBuffer(e) { const t = e.slice(0), r = new Uint8Array(t); for (let e = 0; e < r.length; e += 4)r[e] = r[e + 3], r[e + 1] = r[e + 2], r[e + 2] = 0, r[e + 3] = 0; this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(t)) } fromString(e) { const t = e.length; this.valueBlock.valueHex = new ArrayBuffer(4 * t); const r = new Uint8Array(this.valueBlock.valueHex); for (let n = 0; n < t; n++) { const t = (0, s.utilToBase)(e.charCodeAt(n), 8), i = new Uint8Array(t); if (i.length > 4) continue; const o = 4 - i.length; for (let e = i.length - 1; e >= 0; e--)r[4 * n + e + o] = i[e] } this.valueBlock.value = e } } class W extends (a(o)) { constructor(e = {}) { super(e), this.value = "", this.isHexOnly = !0 } static blockName() { return "SimpleStringValueBlock" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.value = this.value, e } } class j extends u { constructor(e = {}) { super(e, W), "value" in e && this.fromString(e.value) } static blockName() { return "SIMPLESTRING" } fromBER(e, t, r) { const s = this.valueBlock.fromBER(e, t, !0 === this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length); return -1 === s ? (this.error = this.valueBlock.error, s) : (this.fromBuffer(this.valueBlock.valueHex), 0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), 0 === this.valueBlock.error.length && (this.blockLength += this.valueBlock.blockLength), s) } fromBuffer(e) { this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(e)) } fromString(e) { const t = e.length; this.valueBlock.valueHex = new ArrayBuffer(t); const r = new Uint8Array(this.valueBlock.valueHex); for (let s = 0; s < t; s++)r[s] = e.charCodeAt(s); this.valueBlock.value = e } } class _ extends j { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 18 } static blockName() { return "NumericString" } } class $ extends j { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 19 } static blockName() { return "PrintableString" } } class K extends j { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 20 } static blockName() { return "TeletexString" } } class q extends j { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 21 } static blockName() { return "VideotexString" } } class G extends j { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 22 } static blockName() { return "IA5String" } } class z extends j { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 25 } static blockName() { return "GraphicString" } } class Z extends j { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 26 } static blockName() { return "VisibleString" } } class Y extends j { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 27 } static blockName() { return "GeneralString" } } class Q extends j { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 29 } static blockName() { return "CharacterString" } } class X extends Z { constructor(e = {}) { if (super(e), this.year = 0, this.month = 0, this.day = 0, this.hour = 0, this.minute = 0, this.second = 0, "value" in e) { this.fromString(e.value), this.valueBlock.valueHex = new ArrayBuffer(e.value.length); const t = new Uint8Array(this.valueBlock.valueHex); for (let r = 0; r < e.value.length; r++)t[r] = e.value.charCodeAt(r) } "valueDate" in e && (this.fromDate(e.valueDate), this.valueBlock.valueHex = this.toBuffer()), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 23 } fromBER(e, t, r) { const s = this.valueBlock.fromBER(e, t, !0 === this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length); return -1 === s ? (this.error = this.valueBlock.error, s) : (this.fromBuffer(this.valueBlock.valueHex), 0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), 0 === this.valueBlock.error.length && (this.blockLength += this.valueBlock.blockLength), s) } fromBuffer(e) { this.fromString(String.fromCharCode.apply(null, new Uint8Array(e))) } toBuffer() { const e = this.toString(), t = new ArrayBuffer(e.length), r = new Uint8Array(t); for (let t = 0; t < e.length; t++)r[t] = e.charCodeAt(t); return t } fromDate(e) { this.year = e.getUTCFullYear(), this.month = e.getUTCMonth() + 1, this.day = e.getUTCDate(), this.hour = e.getUTCHours(), this.minute = e.getUTCMinutes(), this.second = e.getUTCSeconds() } toDate() { return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)) } fromString(e) { const t = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e); if (null === t) return void (this.error = "Wrong input string for convertion"); const r = parseInt(t[1], 10); this.year = r >= 50 ? 1900 + r : 2e3 + r, this.month = parseInt(t[2], 10), this.day = parseInt(t[3], 10), this.hour = parseInt(t[4], 10), this.minute = parseInt(t[5], 10), this.second = parseInt(t[6], 10) } toString() { const e = new Array(7); return e[0] = (0, s.padNumber)(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2), e[1] = (0, s.padNumber)(this.month, 2), e[2] = (0, s.padNumber)(this.day, 2), e[3] = (0, s.padNumber)(this.hour, 2), e[4] = (0, s.padNumber)(this.minute, 2), e[5] = (0, s.padNumber)(this.second, 2), e[6] = "Z", e.join("") } static blockName() { return "UTCTime" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.year = this.year, e.month = this.month, e.day = this.day, e.hour = this.hour, e.minute = this.minute, e.second = this.second, e } } class ee extends Z { constructor(e = {}) { if (super(e), this.year = 0, this.month = 0, this.day = 0, this.hour = 0, this.minute = 0, this.second = 0, this.millisecond = 0, "value" in e) { this.fromString(e.value), this.valueBlock.valueHex = new ArrayBuffer(e.value.length); const t = new Uint8Array(this.valueBlock.valueHex); for (let r = 0; r < e.value.length; r++)t[r] = e.value.charCodeAt(r) } "valueDate" in e && (this.fromDate(e.valueDate), this.valueBlock.valueHex = this.toBuffer()), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 24 } fromBER(e, t, r) { const s = this.valueBlock.fromBER(e, t, !0 === this.lenBlock.isIndefiniteForm ? r : this.lenBlock.length); return -1 === s ? (this.error = this.valueBlock.error, s) : (this.fromBuffer(this.valueBlock.valueHex), 0 === this.idBlock.error.length && (this.blockLength += this.idBlock.blockLength), 0 === this.lenBlock.error.length && (this.blockLength += this.lenBlock.blockLength), 0 === this.valueBlock.error.length && (this.blockLength += this.valueBlock.blockLength), s) } fromBuffer(e) { this.fromString(String.fromCharCode.apply(null, new Uint8Array(e))) } toBuffer() { const e = this.toString(), t = new ArrayBuffer(e.length), r = new Uint8Array(t); for (let t = 0; t < e.length; t++)r[t] = e.charCodeAt(t); return t } fromDate(e) { this.year = e.getUTCFullYear(), this.month = e.getUTCMonth() + 1, this.day = e.getUTCDate(), this.hour = e.getUTCHours(), this.minute = e.getUTCMinutes(), this.second = e.getUTCSeconds(), this.millisecond = e.getUTCMilliseconds() } toDate() { return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)) } fromString(e) { let t, r = !1, s = "", n = "", i = 0, o = 0, a = 0; if ("Z" === e[e.length - 1]) s = e.substr(0, e.length - 1), r = !0; else { const t = new Number(e[e.length - 1]); if (isNaN(t.valueOf())) throw new Error("Wrong input string for convertion"); s = e } if (r) { if (-1 !== s.indexOf("+")) throw new Error("Wrong input string for convertion"); if (-1 !== s.indexOf("-")) throw new Error("Wrong input string for convertion") } else { let e = 1, t = s.indexOf("+"), r = ""; if (-1 === t && (t = s.indexOf("-"), e = -1), -1 !== t) { if (r = s.substr(t + 1), s = s.substr(0, t), 2 !== r.length && 4 !== r.length) throw new Error("Wrong input string for convertion"); let n = new Number(r.substr(0, 2)); if (isNaN(n.valueOf())) throw new Error("Wrong input string for convertion"); if (o = e * n, 4 === r.length) { if (n = new Number(r.substr(2, 2)), isNaN(n.valueOf())) throw new Error("Wrong input string for convertion"); a = e * n } } } let l = s.indexOf("."); if (-1 === l && (l = s.indexOf(",")), -1 !== l) { const e = new Number(`0${s.substr(l)}`); if (isNaN(e.valueOf())) throw new Error("Wrong input string for convertion"); i = e.valueOf(), n = s.substr(0, l) } else n = s; switch (!0) { case 8 === n.length: if (t = /(\d{4})(\d{2})(\d{2})/gi, -1 !== l) throw new Error("Wrong input string for convertion"); break; case 10 === n.length: if (t = /(\d{4})(\d{2})(\d{2})(\d{2})/gi, -1 !== l) { let e = 60 * i; this.minute = Math.floor(e), e = 60 * (e - this.minute), this.second = Math.floor(e), e = 1e3 * (e - this.second), this.millisecond = Math.floor(e) } break; case 12 === n.length: if (t = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi, -1 !== l) { let e = 60 * i; this.second = Math.floor(e), e = 1e3 * (e - this.second), this.millisecond = Math.floor(e) } break; case 14 === n.length: if (t = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi, -1 !== l) { const e = 1e3 * i; this.millisecond = Math.floor(e) } break; default: throw new Error("Wrong input string for convertion") }const c = t.exec(n); if (null === c) throw new Error("Wrong input string for convertion"); for (let e = 1; e < c.length; e++)switch (e) { case 1: this.year = parseInt(c[e], 10); break; case 2: this.month = parseInt(c[e], 10); break; case 3: this.day = parseInt(c[e], 10); break; case 4: this.hour = parseInt(c[e], 10) + o; break; case 5: this.minute = parseInt(c[e], 10) + a; break; case 6: this.second = parseInt(c[e], 10); break; default: throw new Error("Wrong input string for convertion") }if (!1 === r) { const e = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond); this.year = e.getUTCFullYear(), this.month = e.getUTCMonth(), this.day = e.getUTCDay(), this.hour = e.getUTCHours(), this.minute = e.getUTCMinutes(), this.second = e.getUTCSeconds(), this.millisecond = e.getUTCMilliseconds() } } toString() { const e = []; return e.push((0, s.padNumber)(this.year, 4)), e.push((0, s.padNumber)(this.month, 2)), e.push((0, s.padNumber)(this.day, 2)), e.push((0, s.padNumber)(this.hour, 2)), e.push((0, s.padNumber)(this.minute, 2)), e.push((0, s.padNumber)(this.second, 2)), 0 !== this.millisecond && (e.push("."), e.push((0, s.padNumber)(this.millisecond, 3))), e.push("Z"), e.join("") } static blockName() { return "GeneralizedTime" } toJSON() { let e = {}; try { e = super.toJSON() } catch (e) { } return e.year = this.year, e.month = this.month, e.day = this.day, e.hour = this.hour, e.minute = this.minute, e.second = this.second, e.millisecond = this.millisecond, e } } class te extends T { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 31 } static blockName() { return "DATE" } } class re extends T { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 32 } static blockName() { return "TimeOfDay" } } class se extends T { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 33 } static blockName() { return "DateTime" } } class ne extends T { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 34 } static blockName() { return "Duration" } } class ie extends T { constructor(e = {}) { super(e), this.idBlock.tagClass = 1, this.idBlock.tagNumber = 14 } static blockName() { return "TIME" } } class oe { constructor(e = {}) { this.name = (0, s.getParametersValue)(e, "name", ""), this.optional = (0, s.getParametersValue)(e, "optional", !1) } } t.IK = oe; class ae { constructor(e = {}) { this.name = (0, s.getParametersValue)(e, "name", ""), this.optional = (0, s.getParametersValue)(e, "optional", !1), this.value = (0, s.getParametersValue)(e, "value", new oe), this.local = (0, s.getParametersValue)(e, "local", !1) } } function le(e, t, r) { const n = t; let i = new u({}, Object); const a = new o; if (!1 === (0, s.checkBufferParams)(a, e, t, r)) return i.error = a.error, { offset: -1, result: i }; if (0 === new Uint8Array(e, t, r).length) return this.error = "Zero buffer length", { offset: -1, result: i }; let l = i.idBlock.fromBER(e, t, r); if (i.warnings.concat(i.idBlock.warnings), -1 === l) return i.error = i.idBlock.error, { offset: -1, result: i }; if (t = l, r -= i.idBlock.blockLength, l = i.lenBlock.fromBER(e, t, r), i.warnings.concat(i.lenBlock.warnings), -1 === l) return i.error = i.lenBlock.error, { offset: -1, result: i }; if (t = l, r -= i.lenBlock.blockLength, !1 === i.idBlock.isConstructed && !0 === i.lenBlock.isIndefiniteForm) return i.error = "Indefinite length form used for primitive encoding form", { offset: -1, result: i }; let c = u; switch (i.idBlock.tagClass) { case 1: if (i.idBlock.tagNumber >= 37 && !1 === i.idBlock.isHexOnly) return i.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard", { offset: -1, result: i }; switch (i.idBlock.tagNumber) { case 0: if (!0 === i.idBlock.isConstructed && i.lenBlock.length > 0) return i.error = "Type [UNIVERSAL 0] is reserved", { offset: -1, result: i }; c = B; break; case 1: c = b; break; case 2: c = L; break; case 3: c = S; break; case 4: c = N; break; case 5: c = p; break; case 6: c = I; break; case 10: c = H; break; case 12: c = T; break; case 13: c = D; break; case 14: c = ie; break; case 15: return i.error = "[UNIVERSAL 15] is reserved by ASN.1 standard", { offset: -1, result: i }; case 16: c = y; break; case 17: c = w; break; case 18: c = _; break; case 19: c = $; break; case 20: c = K; break; case 21: c = q; break; case 22: c = G; break; case 23: c = X; break; case 24: c = ee; break; case 25: c = z; break; case 26: c = Z; break; case 27: c = Y; break; case 28: c = M; break; case 29: c = Q; break; case 30: c = V; break; case 31: c = te; break; case 32: c = re; break; case 33: c = se; break; case 34: c = ne; break; default: { let s; s = !0 === i.idBlock.isConstructed ? new m : new g, s.idBlock = i.idBlock, s.lenBlock = i.lenBlock, s.warnings = i.warnings, i = s, l = i.fromBER(e, t, r) } }break; case 2: case 3: case 4: default: c = !0 === i.idBlock.isConstructed ? m : g }return i = function (e, t) { if (e instanceof t) return e; const r = new t; return r.idBlock = e.idBlock, r.lenBlock = e.lenBlock, r.warnings = e.warnings, r.valueBeforeDecode = e.valueBeforeDecode.slice(0), r }(i, c), l = i.fromBER(e, t, !0 === i.lenBlock.isIndefiniteForm ? r : i.lenBlock.length), i.valueBeforeDecode = e.slice(n, n + i.blockLength), { offset: l, result: i } } function ce(e) { if (0 === e.byteLength) { const e = new u({}, Object); return e.error = "Input buffer has zero length", { offset: -1, result: e } } return le(e, 0, e.byteLength) } }, 447: (e, t, r) => { function s(e) { return new Date(e.getTime() + 6e4 * e.getTimezoneOffset()) } function n(e, t, r) { return e instanceof Object == 0 ? r : t in e ? e[t] : r } function i(e, t = 0, r = e.byteLength - t, s = !1) { let n = ""; for (const i of new Uint8Array(e, t, r)) { const e = i.toString(16).toUpperCase(); 1 === e.length && (n += "0"), n += e, s && (n += " ") } return n.trim() } function o(e, t, r, s) { return t instanceof ArrayBuffer == 0 ? (e.error = 'Wrong parameter: inputBuffer must be "ArrayBuffer"', !1) : 0 === t.byteLength ? (e.error = "Wrong parameter: inputBuffer has zero length", !1) : r < 0 ? (e.error = "Wrong parameter: inputOffset less than zero", !1) : s < 0 ? (e.error = "Wrong parameter: inputLength less than zero", !1) : !(t.byteLength - r - s < 0 && (e.error = "End of input reached before message was fully decoded (inconsistent offset and length values)", 1)) } function a(e, t) { let r = 0; if (1 === e.length) return e[0]; for (let s = e.length - 1; s >= 0; s--)r += e[e.length - 1 - s] * Math.pow(2, t * s); return r } function l(e, t, r = -1) { const s = r; let n = e, i = 0, o = Math.pow(2, t); for (let r = 1; r < 8; r++) { if (e < o) { let e; if (s < 0) e = new ArrayBuffer(r), i = r; else { if (s < r) return new ArrayBuffer(0); e = new ArrayBuffer(s), i = s } const o = new Uint8Array(e); for (let e = r - 1; e >= 0; e--) { const r = Math.pow(2, e * t); o[i - e - 1] = Math.floor(n / r), n -= o[i - e - 1] * r } return e } o *= Math.pow(2, t) } return new ArrayBuffer(0) } function c(...e) { let t = 0, r = 0; for (const r of e) t += r.byteLength; const s = new ArrayBuffer(t), n = new Uint8Array(s); for (const t of e) n.set(new Uint8Array(t), r), r += t.byteLength; return s } function h(...e) { let t = 0, r = 0; for (const r of e) t += r.length; const s = new ArrayBuffer(t), n = new Uint8Array(s); for (const t of e) n.set(t, r), r += t.length; return n } function u() { const e = new Uint8Array(this.valueHex); if (this.valueHex.byteLength >= 2) { const t = 255 === e[0] && 128 & e[1], r = 0 === e[0] && 0 == (128 & e[1]); (t || r) && this.warnings.push("Needlessly long format") } const t = new ArrayBuffer(this.valueHex.byteLength), r = new Uint8Array(t); for (let e = 0; e < this.valueHex.byteLength; e++)r[e] = 0; r[0] = 128 & e[0]; const s = a(r, 8), n = new ArrayBuffer(this.valueHex.byteLength), i = new Uint8Array(n); for (let t = 0; t < this.valueHex.byteLength; t++)i[t] = e[t]; return i[0] &= 127, a(i, 8) - s } function f(e) { const t = e < 0 ? -1 * e : e; let r = 128; for (let s = 1; s < 8; s++) { if (t <= r) { if (e < 0) { const e = l(r - t, 8, s); return new Uint8Array(e)[0] |= 128, e } let n = l(t, 8, s), i = new Uint8Array(n); if (128 & i[0]) { const e = n.slice(0), t = new Uint8Array(e); n = new ArrayBuffer(n.byteLength + 1), i = new Uint8Array(n); for (let r = 0; r < e.byteLength; r++)i[r + 1] = t[r]; i[0] = 0 } return n } r *= Math.pow(2, 8) } return new ArrayBuffer(0) } function g(e, t) { if (e.byteLength !== t.byteLength) return !1; const r = new Uint8Array(e), s = new Uint8Array(t); for (let e = 0; e < r.length; e++)if (r[e] !== s[e]) return !1; return !0 } function d(e, t) { const r = e.toString(10); if (t < r.length) return ""; const s = t - r.length, n = new Array(s); for (let e = 0; e < s; e++)n[e] = "0"; return n.join("").concat(r) } r.r(t), r.d(t, { getUTCDate: () => s, getParametersValue: () => n, bufferToHexCodes: () => i, checkBufferParams: () => o, utilFromBase: () => a, utilToBase: () => l, utilConcatBuf: () => c, utilConcatView: () => h, utilDecodeTC: () => u, utilEncodeTC: () => f, isEqualBuffer: () => g, padNumber: () => d, toBase64: () => B, fromBase64: () => v, arrayBufferToString: () => b, stringToArrayBuffer: () => y, nearestPowerOf2: () => p, clearProps: () => x }); const m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", k = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="; function B(e, t = !1, r = !1, s = !1) { let n = 0, i = 0, o = 0, a = ""; const l = t ? k : m; if (s) { let t = 0; for (let r = 0; r < e.length; r++)if (0 !== e.charCodeAt(r)) { t = r; break } e = e.slice(t) } for (; n < e.length;) { const t = e.charCodeAt(n++); n >= e.length && (i = 1); const s = e.charCodeAt(n++); n >= e.length && (o = 1); const c = e.charCodeAt(n++), h = t >> 2, u = (3 & t) << 4 | s >> 4; let f = (15 & s) << 2 | c >> 6, g = 63 & c; 1 === i ? f = g = 64 : 1 === o && (g = 64), a += r ? 64 === f ? `${l.charAt(h)}${l.charAt(u)}` : 64 === g ? `${l.charAt(h)}${l.charAt(u)}${l.charAt(f)}` : `${l.charAt(h)}${l.charAt(u)}${l.charAt(f)}${l.charAt(g)}` : `${l.charAt(h)}${l.charAt(u)}${l.charAt(f)}${l.charAt(g)}` } return a } function v(e, t = !1, r = !1) { const s = t ? k : m; function n(e) { for (let t = 0; t < 64; t++)if (s.charAt(t) === e) return t; return 64 } function i(e) { return 64 === e ? 0 : e } let o = 0, a = ""; for (; o < e.length;) { const t = n(e.charAt(o++)), r = o >= e.length ? 0 : n(e.charAt(o++)), s = o >= e.length ? 0 : n(e.charAt(o++)), l = o >= e.length ? 0 : n(e.charAt(o++)), c = i(t) << 2 | i(r) >> 4, h = (15 & i(r)) << 4 | i(s) >> 2, u = (3 & i(s)) << 6 | i(l); a += String.fromCharCode(c), 64 !== s && (a += String.fromCharCode(h)), 64 !== l && (a += String.fromCharCode(u)) } if (r) { let e = -1; for (let t = a.length - 1; t >= 0; t--)if (0 !== a.charCodeAt(t)) { e = t; break } a = -1 !== e ? a.slice(0, e + 1) : "" } return a } function b(e) { let t = ""; const r = new Uint8Array(e); for (const e of r) t += String.fromCharCode(e); return t } function y(e) { const t = e.length, r = new ArrayBuffer(t), s = new Uint8Array(r); for (let r = 0; r < t; r++)s[r] = e.charCodeAt(r); return r } const w = Math.log(2); function p(e) { const t = Math.log(e) / w, r = Math.floor(t), s = Math.round(t); return r === s ? r : s } function x(e, t) { for (const r of t) delete e[r] } } }, t = {}; function r(s) { if (t[s]) return t[s].exports; var n = t[s] = { exports: {} }; return e[s](n, n.exports, r), n.exports } r.d = (e, t) => { for (var s in t) r.o(t, s) && !r.o(e, s) && Object.defineProperty(e, s, { enumerable: !0, get: t[s] }) }, r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, (() => { var e = r(360); function t(e, t, r) { return e instanceof Object == 0 ? r : t in e ? e[t] : r } function s(e, t = 0, r = e.byteLength - t, s = !1) { let n = ""; for (const i of new Uint8Array(e, t, r)) { const e = i.toString(16).toUpperCase(); 1 === e.length && (n += "0"), n += e, s && (n += " ") } return n.trim() } function n(e, t) { for (const r of t) delete e[r] } Math.log(2); class i { constructor(e = {}) { if ("string" == typeof e) throw new TypeError("Unimplemented: Not accepting string yet."); if (e instanceof ArrayBuffer) { const t = fromBER(e); this.fromSchema(t.result) } else this.algorithmId = t(e, "algorithmId"), "algorithmParams" in e && (this.algorithmParams = t(e, "algorithmParams", i.defaultValues("algorithmParams"))) } static defaultValues(t) { switch (t) { case "algorithmParams": return new e.IK; default: throw new Error(`Invalid member name for AlgorithmIdentifier class: ${t}`) } } static compareWithDefault(e, t) { switch (e) { case "algorithmId": return "" === t; case "algorithmParams": return t instanceof asn1js.Any; default: throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`) } } static schema(r = {}) { const s = t(r, "names", {}); return new e.T9({ name: s.blockName || "", optional: s.optional || !1, value: [new e.rP({ name: s.algorithmIdentifier || "algorithm" }), new e.IK({ name: s.algorithmParams || "parameters", optional: !0 })] }) } fromSchema(t) { n(t, ["algorithm", "params"]); const r = (0, e.eN)(t, t, i.schema({ names: { algorithmIdentifier: "algorithm", algorithmParams: "params" } })); if (!1 === r.verified) throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier"); this.algorithmId = r.result.algorithm.valueBlock.toString(), "params" in r.result && (this.algorithmParams = r.result.params) } toSchema() { const t = []; return t.push(new e.rP({ value: this.algorithmId })), "algorithmParams" in this && this.algorithmParams instanceof asn1js.Any == 0 && t.push(this.algorithmParams), new e.T9({ value: t }) } toJSON() { const e = { algorithmId: this.algorithmId }; return "algorithmParams" in this && this.algorithmParams instanceof asn1js.Any == 0 && (e.algorithmParams = this.algorithmParams.toJSON()), e } isEqual(e) { return e instanceof i != 0 && this.algorithmId === e.algorithmId && ("algorithmParams" in this ? "algorithmParams" in e && JSON.stringify(this.algorithmParams) === JSON.stringify(e.algorithmParams) : !("algorithmParams" in e)) } } class o { constructor(r = {}) { if ("string" == typeof r) throw new TypeError("Not accepting string. For base64, convert to ArrayBuffer."); if (r instanceof ArrayBuffer) { const t = (0, e.sc)(r); this.fromSchema(t.result) } else this.signatureAlgorithm = t(r, "signatureAlgorithm"), this.publicKey = t(r, "publicKey") } static schema(r = {}) { const s = t(r, "names", {}); return new e.T9({ name: s.blockName || "", optional: !0, value: [i.schema(s.signatureAlgorithm || { names: { blockName: "signatureAlgorithm" } }), new e._K({ name: "publicKey" })] }) } fromSchema(t) { if (n(t, ["signatureAlgorithm", "publicKey"]), !1 === (0, e.eN)(t, t, o.schema({ names: { signatureAlgorithm: "signatureAlgorithm", publicKey: "publicKey" } })).verified) throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier") } } class a { constructor(r = {}) { if ("string" == typeof r) throw new TypeError("Unimplemented: Not accepting string yet."); if (r instanceof ArrayBuffer) { const t = (0, e.sc)(r); this.fromSchema(t.result) } else this.devconId = t(r, "devconId"), this.ticketId = t(r, "ticketId"), this.ticketClass = t(r, "ticketClass") } static schema(r = {}) { const s = t(r, "names", {}); return new e.T9({ name: s.blockName || "ticket", value: [new e.z8({ name: s.devconId || "devconId" }), new e.z8({ name: s.ticketId || "ticketId" }), new e.z8({ name: s.ticketClass || "ticketClass" })] }) } fromSchema(t) { n(t, ["devconId", "ticketId", "ticketClass"]); const r = (0, e.eN)(t, t, a.schema()); if (!1 === r.verified) throw new Error("Object's schema was not verified against input data for DevconTicket"); if ("devconId" in r.result) { const e = r.result.devconId.valueBlock._valueHex; this.devconId = BigInt("0x" + s(e)) } if ("ticketId" in r.result) { const e = r.result.ticketId.valueBlock._valueHex; this.ticketId = BigInt("0x" + s(e)) } if ("ticketClass" in r.result) { const e = r.result.ticketClass.valueBlock._valueHex; this.ticketClass = BigInt("0x" + s(e)) } } } class l { constructor(r = {}) { if ("string" == typeof r) { let e = (r.startsWith("https://") ? new URL(r).searchParams.get("ticket") : r).split("_").join("/").split("-").join("+").split(".").join("="); r = "undefined" != typeof Buffer ? Uint8Array.from(Buffer.from(e, "base64")).buffer : Uint8Array.from(atob(e), (e => e.charCodeAt(0))).buffer } if (r instanceof ArrayBuffer) { const t = (0, e.sc)(r); this.fromSchema(t.result) } else this.ticket = new a(r.ticket), this.commitment = t(r, "commitment"), this.publicKeyInfo = new o(r.publicKeyInfo), this.signatureValue = t(r, "signatureValue") } static schema(r = {}) { const s = t(r, "names", {}); return new e.T9({ name: s.blockName || "SignedDevconTicket", value: [a.schema(r), new e.fi({ name: "commitment" }), new e.T9({ name: "publicKeyInfo", optional: !0, value: [o.schema(s.publicKeyInfo || { names: { blockName: "publicKeyInfo" } })] }), new e._K({ name: "signatureValue" })] }) } fromSchema(t) { n(t, ["ticket", "commitment", "publicKeyInfo", "signatureValue"]); const r = (0, e.eN)(t, t, l.schema()); if (!1 === r.verified) throw new Error("Object's schema was not verified against input data for SignedDevconTicket"); this.ticket = new a(r.result.ticket.valueBeforeDecode), "commitment" in r.result && (this.commitment = r.result.commitment.valueBlock.valueHex), this.publicKeyInfo = new o({ schema: r.result.publicKeyInfo }); const s = r.result.signatureValue; this.signatureValue = s.valueBlock.valueHex } } window.Negotiator = class { constructor(e = {}, t = {}) { let r = { attestationOrigin: "https://stage.attestation.id", tokensOrigin: "https://devcontickets.herokuapp.com/outlet/", tokenUrlName: "ticket", tokenSecretName: "secret", unsignedTokenDataName: "ticket", tokenParser: l, localStorageItemName: "dcTokens" }; if (this.queuedCommand = !1, this.filter = e, this.debug = 0, this.hideTokensIframe = 1, this.tokensOrigin = r.tokensOrigin, this.attestationOrigin = r.attestationOrigin, this.tokenUrlName = r.tokenUrlName, this.tokenSecretName = r.tokenSecretName, this.unsignedTokenDataName = r.unsignedTokenDataName, this.tokenParser = r.tokenParser, this.localStorageItemName = r.localStorageItemName, t.hasOwnProperty("debug") && (this.debug = t.debug), t.hasOwnProperty("attestationOrigin") && (this.attestationOrigin = t.attestationOrigin), t.hasOwnProperty("tokensOrigin") && (this.tokensOrigin = t.tokensOrigin), this.isTokenOriginWebsite = !1, this.attestationOrigin) { let e = new URL(window.location.href), t = new URL(this.tokensOrigin); e.origin === t.origin && (console.log("this is tokenOrigin. fire listener and read params"), this.isTokenOriginWebsite = !0, this.readMagicUrl()) } if (window !== window.parent) { this.debug && console.log("negotiator: its iframe, lets return tokens to the parent"), this.attachPostMessageListener(this.listenForParentMessages.bind(this)); let e = new URL(document.referrer); window.parent.postMessage({ iframeCommand: "iframeReady", iframeData: "" }, e.origin) } } listenForParentMessages(e) { let t = new URL(document.referrer); if (e.origin !== t.origin) return; if (void 0 === e.data.parentCommand || void 0 === e.data.parentData) return; let r = e.data.parentCommand, s = e.data.parentData; switch (console.log("iframe: command, data = ", r, s), r) { case "signToken": if (console.log("let Auth data:", s), void 0 === window.Authenticator) return void console.log("Authenticator not defined."); let e = this.getRawToken(s), r = e.token, n = e.secret; this.authenticator = new Authenticator(this), this.authenticator.getAuthenticationBlob({ ticketBlob: r, ticketSecret: n, attestationOrigin: this.attestationOrigin }, (e => { console.log("sign result:", e), window.parent.postMessage({ iframeCommand: "useTokenData", iframeData: { useToken: e, message: "", success: !!e } }, t.origin) })); break; case "tokensList": console.log("let return tokens"), this.returnTokensToParent() } } commandDisplayIframe() { let e = new URL(document.referrer); window.parent.postMessage({ iframeCommand: "iframeWrap", iframeData: "show" }, e.origin) } commandHideIframe() { let e = new URL(document.referrer); window.parent.postMessage({ iframeCommand: "iframeWrap", iframeData: "hide" }, e.origin) } returnTokensToParent() { let e = this.readTokens(); if (e.success && !e.noTokens) { let t = this.decodeTokens(e.tokens), r = this.filterTokens(t); e.tokens = r } let t = new URL(document.referrer); window.parent.postMessage({ iframeCommand: "tokensData", iframeData: e }, t.origin) } readMagicUrl() { const e = new URLSearchParams(window.location.search), t = e.get(this.tokenUrlName), r = e.get(this.tokenSecretName); if (!t || !r) return; let s = this.readTokens(), n = [], i = !0; s.noTokens || (n = s.tokens, n.map((e => { e.token === t && (i = !1) }))), i && n.push({ token: t, secret: r }), localStorage.setItem(this.localStorageItemName, JSON.stringify(n)) } filterTokens(e, t = {}) { 0 == Object.keys(t).length && (t = this.filter); let r = []; if (e.length && "object" == typeof t && Object.keys(t).length) { let s = Object.keys(t); return e.forEach((e => { let n = 1; this.debug && console.log("test token:", e), s.forEach((r => { e[r].toString() != t[r].toString() && (n = 0) })), n && (r.push(e), this.debug && console.log("token fits:", e)) })), r } return e } compareObjects(e, t) { for (var r in e) if (e.hasOwnProperty(r) && e[r].toString() !== t[r].toString()) return !1; for (var r in t) if (t.hasOwnProperty(r) && e[r].toString() !== t[r].toString()) return !1; return !0 } readTokens() { const e = localStorage.getItem(this.localStorageItemName); let t = [], r = { tokens: [], noTokens: !0, success: !0 }; try { e && e.length && (t = JSON.parse(e), 0 !== t.length && t.forEach((e => { e.token && e.secret && r.tokens.push({ token: e.token, secret: e.secret }) })), r.tokens.length && (r.noTokens = !1)) } catch (e) { console.log("Cant parse tokens in LocalStorage"), "function" == typeof callBack && (r.success = !1) } return r } getRawToken(e) { let t = this.readTokens(); if (t.success && !t.noTokens) { let r = t.tokens, s = !1; return r.length && r.forEach((t => { if (t.token) { let r = new this.tokenParser(this.base64ToUint8array(t.token).buffer); if (r && r[this.unsignedTokenDataName]) { let n = r[this.unsignedTokenDataName]; this.compareObjects(n, e) && (s = t) } } else console.log("empty token data received") })), s } } listenForIframeMessages(e) { let t = new URL(this.tokensOrigin); if (e.origin !== t.origin) return; if (void 0 === e.data.iframeCommand || void 0 === e.data.iframeData) return; let r = e.data.iframeCommand, s = e.data.iframeData; switch (console.log("parent: command, data = ", r, s), r) { case "iframeWrap": "show" == s ? this.tokenIframeWrap.style.display = "block" : "hide" == s && (this.tokenIframeWrap.style.display = "none"); break; case "tokensData": this.detachPostMessageListener(this.listenForIframeMessages), this.tokenIframeWrap.remove(), s.success && !s.noTokens && (s.tokens = this.filterTokens(s.tokens)), this.negotiateCallback(s); break; case "useTokenData": this.tokenIframeWrap.remove(), console.log("this.signCallback(data)"), this.signCallback && this.signCallback(s), this.signCallback = !1; break; case "iframeReady": e.source.postMessage(this.queuedCommand, e.origin), this.queuedCommand = "" } } signToken(e, t) { this.signCallback = t, this.queuedCommand = { parentCommand: "signToken", parentData: e }, this.createIframe() } negotiate(e) { if ("function" != typeof e) return !1; if (console.log("negotiateCallback added;"), this.negotiateCallback = e, console.log("attestationOrigin = " + this.attestationOrigin), this.attestationOrigin) if (window.location.href === this.tokensOrigin) { let e = this.readTokens(); if (e.success && !e.noTokens) { let t = this.decodeTokens(e.tokens), r = this.filterTokens(t); e.tokens = r, this.negotiateCallback(e) } } else this.queuedCommand = { parentCommand: "tokensList", parentData: "" }, this.createIframe(); else console.log("no attestationOrigin...") } createIframe() { console.log("open iframe"), this.attachPostMessageListener(this.listenForIframeMessages.bind(this)); const e = document.createElement("iframe"); this.iframe = e, e.src = this.tokensOrigin, e.style.width = "800px", e.style.height = "700px", e.style.maxWidth = "100%", e.style.background = "#fff"; let t = document.createElement("div"); this.tokenIframeWrap = t, t.setAttribute("style", "width:100%; min-height: 100vh; position: fixed; align-items: center; justify-content: center; display: none; top: 0; left: 0; background: #fffa"), t.appendChild(e), document.body.appendChild(t) } base64ToUint8array(e) { let t; return e = e.split("-").join("+").split("_").join("/").split(".").join("="), t = "undefined" != typeof Buffer ? Uint8Array.from(Buffer.from(e, "base64")) : Uint8Array.from(atob(e), (e => e.charCodeAt(0))), t } decodeTokens(e) { this.debug && (console.log("decodeTokens fired"), console.log(e)); let t = []; return e.length && e.forEach((e => { if (e.token) { let r = new this.tokenParser(this.base64ToUint8array(e.token).buffer); r && r[this.unsignedTokenDataName] && t.push(r[this.unsignedTokenDataName]) } else console.log("empty token data received") })), t } attachPostMessageListener(e) { window.addEventListener ? window.addEventListener("message", e, !1) : window.attachEvent("onmessage", e) } detachPostMessageListener(e) { window.addEventListener ? window.removeEventListener("message", e, !1) : window.detachEvent("onmessage", e) } } })() })();